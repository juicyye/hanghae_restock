## 🛍 재입고 알림 시스템 시나리오
### 1. 재입고 알림 신청
- 유저는 상품별 재입고 알림을 신청한다
- 한 번에 하나의 상품만 재입고 알림을 한다고 가정한다
### 2. 상품 재입고 알림
- 상품의 재고상태와 재입고 회차를 변경한다
- 해당 상품의 재입고 신청한 유저를 조회한다 (한 번 조회시 500명)
- 재입고 회차와는 상관없이 모두 알림을 보낸다
  - 재입고 회차는 몇 번 재입고를 했는지 확인한다고 생각했다
  - 재입고 알림을 받았더라도 그 때 안샀을 수도 있고, 마음에 들어서 여러 개 살 수 있다고 가정한다
- 재입고 발송 상태를 변경한다 (메모리)
### 3. 재입고 발송 중 품절
- 알림을 보내기 전에 재고여부를 확인한다
- 만약 재고가 있다고 그대로 알림을 보낸다
- 재고가 없다면 에러를 반환하지만 그 전에 통과한 알림들을 그대로 DB에 저장한다
- 재입고 알림 히스토리에는 재고 부족으로 인한 알림 취소를 저장하고 마지막 발송 유저 아이디도 저장한다
### 4. 재입고 발송 중 오류
- 재입고 알림 히스토리에 오류로 인한 알림 취소를 저장하고 마지막 발송 유저 아이디도 저장한다
### 5. 재입고 알림 히스토리
- 상품별 재입고 알림 히스토리에 정상적으로 저장한다

## 🔧 주요 기능
### 유저 알림 정보
- 상품에 대해 알림 신청을 한 유저들을 커서 페이지네이션 기반으로 DB에서 500개를 가져온다
- 가져온 유저들을 반복문으로 유저 알림 정보 DB에 저장한다
- 상품의 재고는 캐시에 있는 상품상태에 따라 유저 알림 정보가 저장이 될지 안될지가 결정된다
### 상품 알림 정보
- 알림 정보는 정상 종료와 예외 종료에 따라 알림 정보가 달라지며 DB에 저장이 된다
- 상품의 재고는 먼저 캐시에 저장을 하고 DB에 저장을 한다

## ⚠️ 유효성 검사 및 예외 상황
- 상품의 재고가 떨어지면 예외를 반환한다
- Third Party 연동에서 예외가 발생하면 예외를 반환한다 (구현 x)

## 🛠 기술적 의사결정
- Product와 ProductNotificationHistory를 Cache에 저장한 이유
  - 유저수만큼 Product를 DB에서 가져오게 되면 부하가 될 것이라고 생각했습니다.
  - 차라리 Map에 Product를 저장을 해서 수정을 하고 확인하는 쪽이 더 나을 것이라고 판단했습니다.
  - Product에 재고가 있는지 여부는 DB에서 확인하나 캐시에서 확인하나 문제 될 것이 없고 변동사항이 많을수록 DB에 저장하는 것이 부담이 갈 것이라고 생각했습니다.
- ProductNotificationHistory는 알림이 다 끝날때까지 DB에 저장을 하면 안될 것이라고 판단했습니다.
  - 애초에 알림이 끝나야 정확한 정보가 들어갈 것이고, 예외가 발생하더라도 마지막 정보만 들어가도록 설정하면 될 것이라고 생각했습니다.
- processNotification이 `@Transactional(propagation = Propagation.REQUIRES_NEW, noRollbackFor = NotificationException.class)`인 이유
  - 유저 100까지는 재고가 있다가 101부터 재고가 없다고 한다면 100까지는 저장이 되도록 하고 예외를 발생해 알림 정보에 취소를 저장하도록 했습니다.
  - `propagation = Propagation.REQUIRES_NEW`을 꼭 적을 필요는 없다고 생각하지만 (하나의 트랜잭션을 사용하지는 않아서) 독립적으로 실행된다는 걸 명시적으로 알려주고 싶었습니다.
